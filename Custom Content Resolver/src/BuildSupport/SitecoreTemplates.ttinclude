<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="System.Core" #>
<#

// NOTE - Reference your NuGet packages for Rainbow and RainbowCodeGeneration here.
//        There is currently a fixed version dependency between RainbowCodeGeneration and Rainbow.Core.2.0.0 so
//        this is referenced from /dep to allow the project itself to reference the newer version via NuGet.

#>
<#@ assembly name="$(SolutionDir)..\dep\Rainbow.Core.2.0.0.dll" #>
<#@ assembly name="$(SolutionDir)packages\Rainbow.Storage.Yaml.2.0.5\lib\net452\Rainbow.Storage.Yaml.dll" #>
<#@ assembly name="$(SolutionDir)..\dep\RainbowCodeGeneration.dll" #>
<#

// NOTE - Reference your Sitecore.Kernel.dll and Sitecore.Logging.dll here - for Sitecore 9, also add Microsoft.Extensions.DependencyInjection 1.0.0 via NuGet and enable the reference below

#>
<#@ assembly name="$(SolutionDir)packages\Sitecore.Kernel.9.1.1\lib\net471\Sitecore.Kernel.dll" #>
<#@ assembly name="$(SolutionDir)packages\Sitecore.Logging.9.1.1\lib\net471\Sitecore.Logging.dll" #>
<#@ assembly name="$(SolutionDir)packages\Microsoft.Extensions.DependencyInjection.Abstractions.2.1.1\lib\netstandard2.0\Microsoft.Extensions.DependencyInjection.Abstractions.dll" #>
<#@ assembly name="$(SolutionDir)packages\Microsoft.Extensions.DependencyInjection.2.1.1\lib\netstandard2.0\Microsoft.Extensions.DependencyInjection.dll" #>
<#@ import namespace="RainbowCodeGeneration" #>
<#+

const string Tool = "RainbowCodeGeneration";
const string ToolVersion = "1.0";

protected void StartGeneratedStruct(string outputNamespace, string className)
{
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated based on the serialised Unicorn items.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// ReSharper disable InconsistentNaming
namespace <#= outputNamespace #>
{
	using global::Sitecore.Data;

	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#=Tool#>", "<#=ToolVersion#>")]
	public struct <#=className#>
	{
<#+
}

protected class RenderOptions
{
    public bool IncludeTemplateId { get; set; } = true;
	public bool IncludeId { get; set; } = true;
	public bool IncludePath { get; set;} = true;
}

protected void EndGeneratedStruct()
{
	WriteLineIndented(1, "}");
	WriteLine("}");
}

protected void GenerateSitecoreEditFrameButtons(string physicalFileStore, string treeName, string treePath, string outputNamespace, string className = "SitecoreEditFrameButtons", bool skipFirstLevel = true)
{
	var options = new RenderOptions {
		IncludeTemplateId = false,		// We don't need to know the template ID of edit frame buttons
		IncludeId = false,				// Don't need to know the ID of each item 
	};

	// This path should be a folder of buttons, so skip the top-level item (folder) it points to
	GenerateItemsFile(physicalFileStore, treeName, treePath, outputNamespace, className, skipFirstLevel: skipFirstLevel, options: options);
}

protected void GenerateItemsFile(string physicalFileStore, string treeName, string treePath, string outputNamespace, string className, bool skipFirstLevel = false, RenderOptions options = null)
{
	options = options ?? new RenderOptions();

	var items = RainbowCodeGeneration.RainbowReader.GetItems(Host.ResolvePath(physicalFileStore), treeName, treePath);

	if (skipFirstLevel)
	{
		if(items.Count() == 1)
		{
			items = items.First().GetChildren();
		}
		else
		{
			throw new Exception("Unable to pass skipFirstLevel = true unless there is exactly one item");
		}
	}

	items = items.OrderBy(item => item.Name).ToList();


	StartGeneratedStruct(outputNamespace, className);

	var isFirst = true;
	foreach(var item in items)
	{
		if(isFirst) { isFirst = false; } else { WriteLine(""); }
		RenderItemsRecursively(item, 2, options);
	}

	EndGeneratedStruct();
}

protected void GenerateSitecoreTemplates(string physicalFileStore, string treeName, string treePath, string outputNamespace, string className = "SitecoreTemplates")
{
	StartGeneratedStruct(outputNamespace, className);

	var templates = RainbowCodeGeneration.RainbowReader.GetTemplates(Host.ResolvePath(physicalFileStore), treeName, treePath);
	if(templates != null)
	{
		templates = templates.OrderBy(ti => ti.Item.Name);
	}
	RenderTemplates(templates);

	EndGeneratedStruct();
}

protected void WriteLineIndented(int indent, string text, params object[] args)
{
    Write(new string('\t', indent));
	if(args == null || args.Length == 0)
		WriteLine(text);
	else
		WriteLine(string.Format(text, args));
}

protected void WriteConditionalParagraphLine(int indent, string value)
{
	if(!string.IsNullOrWhiteSpace(value))
		WriteLineIndented(indent, "/// <para>{0}</para>", value);
}

protected void WriteIndentedToolVersion(int indent)
{
	WriteLineIndented(indent, "[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{0}\", \"{1}\")]", Tool, ToolVersion);
}

/// <summary>Writes a property. Will write a blank line before if propertyNumber > 0.</summary>
protected void WriteProperty(int indent, string summary, string propertyDefinition, int propertyNumber)
{
	WriteProperty(indent, summary, propertyDefinition, propertyNumber > 0);
}

protected void WriteProperty(int indent, string summary, string propertyDefinition, bool blankLineBefore = true)
{
	if (blankLineBefore)
		WriteLine("");

	WriteLineIndented(indent, "/// <summary>");
	WriteLineIndented(indent, "/// {0}", summary);
	WriteLineIndented(indent, "/// </summary>");
	WriteIndentedToolVersion(indent);
	WriteLineIndented(indent, propertyDefinition);
}

protected void RenderItemsRecursively(Rainbow.Model.IItemData item, int indent, RenderOptions options)
{ 
	WriteLineIndented(indent, "/// <summary>");
	WriteLineIndented(indent, "/// {0}", item.Name);
	WriteConditionalParagraphLine(indent, item.GetSharedField("__Short description"));
	WriteLineIndented(indent, "/// <para>Path: {0}</para>", item.Path);
	WriteLineIndented(indent, "/// <para>ID: {0}</para>", item.Id);
	WriteLineIndented(indent, "/// </summary>");
	WriteIndentedToolVersion(indent);
	WriteLineIndented(indent, "public struct {0}", StringExtensions.AsClassName(item.Name));
	WriteLineIndented(indent, "{");
	indent++;

	var propertyNumber = 0;

	if (options.IncludeId)
		WriteProperty(indent, "The ID for " + item.Path, "public static ID Id = new ID(\"{" + item.Id + "}\");", propertyNumber++);

	if(options.IncludePath)
		WriteProperty(indent, "The path to this item: " + item.Path, "public const string Path = \"" + item.Path + "\";", propertyNumber++);

	if(options.IncludeTemplateId)
		WriteProperty(indent, "The TemplateId string for " + item.Path, "public const string TemplateId = \"" + item.TemplateId + "\";", propertyNumber++);

	var children = item.GetChildren();
	if(children != null && children.Any())
	{
		children = children.OrderBy(child => child.Name).ToList();
		foreach (var child in children)
		{ 
			WriteLine("");
			RenderItemsRecursively(child, indent, options);
		} 
	}

	indent--;
	WriteLineIndented(indent, "}");
}

protected void RenderTemplates(IEnumerable<RainbowCodeGeneration.Models.Template> templates)
{
	var isFirst = true;

	foreach (var template in templates)
	{

		if(isFirst) { isFirst = false; } else { WriteLine(""); }
	
		WriteLineIndented(2, "/// <summary>");
		WriteLineIndented(2, "/// {0}", template.Item.Name);
		WriteConditionalParagraphLine(2, template.Item.GetSharedField("__Short description"));

		WriteLineIndented(2, "/// <para>Path: {0}</para>", template.Item.Path);
		WriteLineIndented(2, "/// <para>ID: {0}</para>", template.Item.Id);
		WriteLineIndented(2, "/// </summary>");

		WriteIndentedToolVersion(2);
		WriteLineIndented(2, "public struct " + StringExtensions.AsClassName(template.Item.Name));
		WriteLineIndented(2, "{");

		WriteProperty(3, "The ID for " + template.Item.Path, "public static ID Id = new ID(\"{" + template.Item.Id + "}\");", false);
		WriteProperty(3, "The TemplateId string for " + template.Item.Path, "public const string TemplateId = \"" + template.Item.Id + "\";");
		WriteProperty(3, "The Template Path string for " + template.Item.Path, "public const string TemplatePath = \"" + template.Item.Path + "\";");
	
		foreach (var field in template.Fields.OrderBy(f => f.Name))
		{
			WriteLine("");
			WriteLineIndented(3, "/// <summary>");
			WriteLineIndented(3, "/// The " + field.Name + " field.");
			WriteConditionalParagraphLine(3, field.GetSharedField("__Short description"));
			WriteLineIndented(3, "/// <para>Field Type: {0}</para>", field.GetSharedField("Type"));
			WriteLineIndented(3, "/// </summary>");
			WriteLineIndented(3, "public struct {0}", StringExtensions.AsClassName(field.Name == template.Item.Name ? field.Name + "_Field" : field.Name));
			WriteLineIndented(3, "{");
			WriteLineIndented(4, "public const string FieldName = \"{0}\";", field.Name);
			WriteLineIndented(4, "public const string FieldName_ToLowerInvariant = \"{0}\";", field.Name.ToLowerInvariant());
			WriteLineIndented(3, "}");
		} // foreach field
	
		WriteLineIndented(2, "}");

	} // foreach template 

} // end RenderTemplates

#>
